#version 430

layout (local_size_x = 16, local_size_y = 16) in;

layout(std430, binding = 0) buffer HeightmapBuffer {
    float heightmap[];
};

uniform ivec2 chunkStartPos;
uniform float scale;
uniform int width;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

vec2 gradient(vec2 p) {
    float angle = 6.2831853 * hash(p);
    return vec2(cos(angle), sin(angle));
}

float perlin(vec2 p) {
    vec2 pi = floor(p);
    vec2 pf = fract(p);

    vec2 g00 = gradient(pi + vec2(0.0, 0.0));
    vec2 g10 = gradient(pi + vec2(1.0, 0.0));
    vec2 g01 = gradient(pi + vec2(0.0, 1.0));
    vec2 g11 = gradient(pi + vec2(1.0, 1.0));

    vec2 d00 = pf - vec2(0.0, 0.0);
    vec2 d10 = pf - vec2(1.0, 0.0);
    vec2 d01 = pf - vec2(0.0, 1.0);
    vec2 d11 = pf - vec2(1.0, 1.0);

    float v00 = dot(g00, d00);
    float v10 = dot(g10, d10);
    float v01 = dot(g01, d01);
    float v11 = dot(g11, d11);

    vec2 fade = pf * pf * pf * (pf * (pf * 6.0 - 15.0) + 10.0);

    float x1 = mix(v00, v10, fade.x);
    float x2 = mix(v01, v11, fade.x);
    return mix(x1, x2, fade.y);
}

float fractalPerlin(vec2 p, int octaves, float persistence, float lacunarity) {
    float total = 0.0;
    float frequency = 1.0;
    float amplitude = 1.0;
    float maxValue = 0.0;

    for (int i = 0; i < octaves; i++) {
        total += perlin(p * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }

    return total / maxValue;
}

void main() {
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);
    ivec2 worldPos = chunkStartPos + id;
    vec2 noiseInput = vec2(worldPos) * scale;
    float height = fractalPerlin(noiseInput, 5, 0.5, 2.0);
    int index = id.y * width + id.x;
    heightmap[index] = height;
}